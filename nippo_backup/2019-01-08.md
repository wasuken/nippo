# 体調

体調を崩してしまった。メンタル弱すぎて辛い。

今日の午前もほぼ寝たきりだった。

日報も二日ほどサボった。いや書いてはいたんだが内容がマイナスすぎてやめといた。

私もLinusさんみたいに罵倒ならぬマイナスな文章を置き換えるツール作りたい。

いや一度作ろうとしたけどIBM Watson Tone API難しすぎて使えなかった・・・。

頭はチンパンでメンタルは豆腐で性格も悪いのでどこかで突然逆らいようのない事故で楽に死ねたらなとか考えたりする今日この頃。

# 数学

```
euclideanAlgorithm :: Int -> Int -> Int
euclideanAlgorithm dividend divisor
  | result == 0 = divisor
  | otherwise = euclideanAlgorithm divisor result
  where result = dividend `mod` divisor
```

わーいユークリッドの互除法。

何が数学だ。お前は小学生レベルの問題しか解けないカスだ。

フェルマーの小定理とその応用してるのがRSA公開鍵暗号方式らしいので実装してみる。

ちなみにHaskellで実装したものを公開した人はすでにいるみたいでそれを参考に・・・。

とここでフェルマーの小定理がまず理解できない。

とりあえずreplで数式を書いてみよう。

```
fermatLittleTheorem :: Int -> Int -> Int
fermatLittleTheorem a p = a ^ (p - 1) `mod` p
```

でここから発展するらしいけどほんの説明だけじゃ全然わからなかった。。。

ブログ漁るのもよかったんだが、ここは読まずに放置してたかの有名な暗号技術入門を利用することにした。

その過程で最小公倍数を求めてくれるlcmという関数を知ったり、それがHaskellでちゃんと定義されてたり(なお実装後に気がついた模様。)

ちなみに最小公倍数を求める関数もあるということは最大公約数を求める関数もあるわけで(gcd)完全に車輪の再発明だった。

で、これを作成するにあたって、乱数で素数な数を生成する必要があるっぽいのでまずはそれから作っていかねばならない。

素数作るだけならprimeNumberListという前回作ったものを使えばいいんだけど乱数じゃないしでかい数値作るとクソみたいに遅くなるので使えない。

そうなると乱数を素数が出るまで生成し続ける関数が必要となる。

一応素数の判定方法はフェルマーテストやミラー・ラビンテスト等があるみたいなので当然楽な方を選んで実装する。

Haskellで乱数を生成するならSystem.Randomパッケージを利用すれば行けるみたいだが

どうやら初期から入っていない？(Stackで生成された状態のプロジェクトにはなかった)みたいなので

```
stack install random
```

する必要があった。splitと一緒だ。

色々やったけど結局今日は乱数を利用することすらできなかった。

randomRIOで乱数は手に入る。randomRでInt型の乱数は手に入るがこれじゃない。

IO IntegerのIOがよくわかってない。IOを引き剥がそうとしてるけど全くわからない。

とにかくIOモナドがわけわからなすぎてダメだった。

Haskell、ダメかもしれない（二回目）

# Haskell環境

全然できない。何がEmacs歴2年だ。お前に利用されているEmacsがかわいそうで仕方がない。

仕方なくauto-complete-modeで補間するようにしたけど遅すぎて使い物にならない。

---

ところで久しくLisp書いてないのでケバブケース使いたくなってきた。ケバブケース一番好きかも。

# 英語

やってない。

# 今日やったこと

* 数学

# 明日やること

* 生きる。

* 数学

* 英語
